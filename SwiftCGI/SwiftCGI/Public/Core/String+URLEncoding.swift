// Copyright 2015 Tony Allevato
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


/// The set of unreserved UTF-8 code units in percent encoding as defined by
/// [RFC 3986](https://tools.ietf.org/html/rfc3986).
private let URLEncodingUnreservedCodeUnits: Set<UTF8.CodeUnit> = {
  /// Helper function that returns an array containing the UTF-8 code units between `start` and
  /// `end`, inclusive.
  func codeUnitRangeArray(start: UnicodeScalar, _ end: UnicodeScalar) -> [UTF8.CodeUnit] {
    return (start.value...end.value).map { UTF8.CodeUnit($0) }
  }

  var set = Set<UTF8.CodeUnit>()
  set.unionInPlace(codeUnitRangeArray("A", "Z"))
  set.unionInPlace(codeUnitRangeArray("a", "z"))
  set.unionInPlace(codeUnitRangeArray("0", "9"))
  set.insert(UTF8.CodeUnit(UnicodeScalar("-").value))
  set.insert(UTF8.CodeUnit(UnicodeScalar("_").value))
  set.insert(UTF8.CodeUnit(UnicodeScalar(".").value))
  set.insert(UTF8.CodeUnit(UnicodeScalar("~").value))
  return set
}()


/// The UTF-8 code unit that represents the "%" sign.
private let URLEncodingPercentCodeUnit: UTF8.CodeUnit = 0x25


public extension String {

  /// URL-encodes the receiver (applies percent encoding) and returns the result.
  ///
  /// - Returns: The receiver with percent encoding applied.
  public var URLEncodedString: String {
    var encoded = String()
    for byte in utf8 {
      if URLEncodingUnreservedCodeUnits.contains(byte) {
        // Let unreserved code units pass through unchanged.
        encoded.append(UnicodeScalar(byte))
      } else {
        // For code units not in the unreserved set, append a "%" followed by the hexadecimal
        // representation of that byte.
        let hex = String(byte, radix: 16, uppercase: true)
        encoded += "%\(hex)"
      }
    }
    return encoded
  }

  /// URL-decodes the receiver (removes percent encoding) and returns the result.
  ///
  /// - Returns: The receiver with percent encodings removed, or nil if the string was not properly
  ///            encoded.
  public var URLDecodedString: String? {
    var utf8Codec = UTF8()
    var decoded = String()
    var generator = UTF8PercentDecodingGenerator(sourceGenerator: utf8.generate())

    var decoding = true
    while decoding {
      let result = utf8Codec.decode(&generator)
      switch result {
      case .Result(let unicodeScalar):
        decoded.append(unicodeScalar)
      case .EmptyInput:
        decoding = false
      case .Error:
        return nil
      }
    }
    return generator.improperlyEncoded ? nil : decoded
  }
}


/// A generator that takes the generator for a UTF-8 view of a string and generates a new sequence
/// that has percent-encoded sequences automatically decoded.
///
/// For example, given the UTF-8 sequence ["A", "%", "2", "E", "B"], this struct would generate the
/// sequence ["A", ".", "B"].
private struct UTF8PercentDecodingGenerator: GeneratorType {

  /// The type of elements generated by this generator.
  typealias Element = UTF8.CodeUnit

  /// The underlying generator that represents the UTF-8 code unit sequence being decoded.
  private var sourceGenerator: String.UTF8View.Generator

  /// This flag will be set to true if the UTF-8 code unit sequence represents an improper percent
  /// encoding (for example, the sequence ending before a complete "%XX" pattern or if the pattern
  /// contains non-hexadecimal digits).
  var improperlyEncoded = false

  /// Creates a new percent decoding generator with the given UTF-8 view generator.
  ///
  /// - Parameter sourceGenerator: The generator for the UTF-8 view that should be percent decoded.
  init(sourceGenerator: String.UTF8View.Generator) {
    self.sourceGenerator = sourceGenerator
  }

  /// Returns the next code unit, or nil if we have reached the end of the sequence.
  ///
  /// - Returns: The next code unit, or nil if we have reached the end of the sequence.
  mutating func next() -> UTF8.CodeUnit? {
    if let codeUnit = sourceGenerator.next() {
      if codeUnit == URLEncodingPercentCodeUnit {
        let highNybbleCodeUnit = sourceGenerator.next()
        let lowNybbleCodeUnit = sourceGenerator.next()

        if let highNybbleCodeUnit = highNybbleCodeUnit, lowNybbleCodeUnit = lowNybbleCodeUnit {
          // Convert the hexadecimal sequence into its numeric value, if possible.
          let highNybble = UnicodeScalar(highNybbleCodeUnit)
          let lowNybble = UnicodeScalar(lowNybbleCodeUnit)

          let hexByte = "\(highNybble)\(lowNybble)"
          let hexValue = UTF8.CodeUnit(hexByte, radix: 16)

          if let hexValue = hexValue {
            // Return the valid hex value from the two digits after the "%" character.
            return hexValue
          } else {
            // The two characters after a "%" did not form a valid hexadecimal number, so the string
            // is improperly encoded. Return nil immediately.
            improperlyEncoded = true
            return nil
          }
        } else {
          // Ran out of code units before we finished decoding a "%XX" pattern. Not enough to
          // coalesce so we return nil immediately.
          improperlyEncoded = true
          return nil
        }
      } else {
        // Since the code unit wasn't "%", we just return it verbatim.
        return codeUnit
      }
    } else {
      // The underlying generator returned nil, so we do as well.
      return nil
    }
  }
}
